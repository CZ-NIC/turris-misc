From 7f6c27d6471a48184454c915edc2ce148db188fc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Karel=20Ko=C4=8D=C3=AD?= <karel.koci@nic.cz>
Date: Mon, 22 May 2017 10:20:35 +0200
Subject: [PATCH] Add no-replan option to pkgupdate

When we are not using pkgupdate from packages (for example when we are
running it in different root) then there is no reason to do replan. It
might even cause problems when we are installing clean to clean root.
This new option allows can be specified to deny replanning and that way
ensure that everything is installed at once.
---
 src/lib/arguments.c               | 10 +++++++++-
 src/lib/arguments.h               |  2 ++
 src/lib/autoload/a_12_planner.lua |  4 ++--
 src/lib/autoload/a_13_updater.lua | 11 ++++++++---
 src/pkgupdate/main.c              | 10 +++++++++-
 tests/planner.lua                 |  8 ++++----
 6 files changed, 34 insertions(+), 11 deletions(-)

diff --git a/src/lib/arguments.c b/src/lib/arguments.c
index 0ff0fba..40bdd4f 100644
--- a/src/lib/arguments.c
+++ b/src/lib/arguments.c
@@ -76,6 +76,8 @@ static const char *opt_help[COT_LAST] = {
 		"--exclude=<name>		Exclude this from output.\n",
 	[COT_USIGN] =
 		"--usign=<path>			Path to usign tool used to verify packages signature. In default /usr/bin/usign.\n",
+	[COT_NO_REPLAN] =
+		"--no-replan			Don't replan. Install everyting at once. Use this if updater you are running isn't from packages it installs.\n",
 	[COT_TASK_LOG] =
 		"--task-log=<file>		Append list of executed tasks into a log file.\n"
 };
@@ -91,6 +93,7 @@ enum option_val {
 	OPT_TASK_LOG_VAL,
 	OPT_EXCLUDE,
 	OPT_USIGN,
+	OPT_NO_REPLAN,
 	OPT_LAST
 };
 
@@ -111,6 +114,7 @@ static const struct option opt_long[] = {
 	{ .name = "task-log", .has_arg = required_argument, .val = OPT_TASK_LOG_VAL },
 	{ .name = "exclude", .has_arg = required_argument, .val = OPT_EXCLUDE },
 	{ .name = "usign", .has_arg = required_argument, .val = OPT_USIGN },
+	{ .name = "no-replan", .has_arg = no_argument, .val = OPT_NO_REPLAN },
 	{ .name = NULL }
 };
 
@@ -132,7 +136,8 @@ static const struct simple_opt {
 	[OPT_OUTPUT] = { COT_OUTPUT, true, true },
 	[OPT_TASK_LOG_VAL] = { COT_TASK_LOG, true, true },
 	[OPT_EXCLUDE] = { COT_EXCLUDE, true, true },
-	[OPT_USIGN] = { COT_USIGN, true, true }
+	[OPT_USIGN] = { COT_USIGN, true, true },
+	[OPT_NO_REPLAN] = { COT_NO_REPLAN, false, true }
 };
 
 // Builds new result with any number of error messages. But specify their count as
@@ -241,6 +246,9 @@ struct cmd_op *cmd_args_parse(int argc, char *argv[], const enum cmd_op_type acc
 			case COT_ASK_APPROVAL:
 			case COT_OUTPUT:
 			case COT_APPROVE:
+			case COT_EXCLUDE:
+			case COT_USIGN:
+			case COT_NO_REPLAN:
 			case COT_TASK_LOG: {
 				struct cmd_op tmp = result[i];
 				for (size_t j = i; j > set_pos; j --)
diff --git a/src/lib/arguments.h b/src/lib/arguments.h
index 1c3b9e3..51614bd 100644
--- a/src/lib/arguments.h
+++ b/src/lib/arguments.h
@@ -68,6 +68,8 @@ enum cmd_op_type {
 	COT_EXCLUDE,
 	// Path to usign tool
 	COT_USIGN,
+	// Don't replan (do whole install at once)
+	COT_NO_REPLAN,
 	// Argument isn't option.
 	COT_NO_OP,
 	// Automatic last dummy value to know size of enum
diff --git a/src/lib/autoload/a_12_planner.lua b/src/lib/autoload/a_12_planner.lua
index d10f1c0..4935964 100644
--- a/src/lib/autoload/a_12_planner.lua
+++ b/src/lib/autoload/a_12_planner.lua
@@ -698,7 +698,7 @@ leave the extra (eg. requiring already installed package) out. And creates
 additional requests with action "remove", such package is present on system, but
 is not required any more and should be removed.
 ]]
-function filter_required(status, requests)
+function filter_required(status, requests, allow_replan)
 	local install, unused = check_install_version(status, requests)
 	install = check_abi_change(requests, install)
 	local result = {}
@@ -712,7 +712,7 @@ function filter_required(status, requests)
 				req.action = "require"
 			end
 			table.insert(result, req)
-			if request.modifier.replan then
+			if request.modifier.replan and allow_replan then
 				replan = true
 				break
 			end
diff --git a/src/lib/autoload/a_13_updater.lua b/src/lib/autoload/a_13_updater.lua
index f333c28..e3f5fcd 100644
--- a/src/lib/autoload/a_13_updater.lua
+++ b/src/lib/autoload/a_13_updater.lua
@@ -36,7 +36,12 @@ local transaction = require "transaction"
 
 module "updater"
 
--- luacheck: globals prepare pre_cleanup cleanup required_pkgs
+-- luacheck: globals prepare pre_cleanup cleanup required_pkgs disable_replan
+
+local allow_replan = true
+function disable_replan()
+	allow_replan = false
+end
 
 function required_pkgs(entrypoint)
 	-- Get the top-level script
@@ -61,7 +66,7 @@ function prepare(entrypoint)
 	local required = required_pkgs(entrypoint)
 	local run_state = backend.run_state()
 	backend.flags_load()
-	local tasks = planner.filter_required(run_state.status, required)
+	local tasks = planner.filter_required(run_state.status, required, allow_replan)
 	--[[
 	Start download of all the packages. They all start (or queue, if there are
 	too many). We then start taking them one by one, but that doesn't stop it
@@ -134,7 +139,7 @@ end
 
 -- Note: This function don't have to return
 function cleanup(success, reboot_finished)
-	if transaction.cleanup_actions.reexec then
+	if transaction.cleanup_actions.reexec and allow_replan then
 		if reboot_finished then
 			reexec('--reboot-finished')
 		else
diff --git a/src/pkgupdate/main.c b/src/pkgupdate/main.c
index b164e69..2ee0027 100644
--- a/src/pkgupdate/main.c
+++ b/src/pkgupdate/main.c
@@ -46,7 +46,7 @@ static bool results_interpret(struct interpreter *interpreter, size_t result_cou
 }
 
 static const enum cmd_op_type cmd_op_allows[] = {
-	COT_BATCH, COT_NO_OP, COT_REEXEC, COT_REBOOT, COT_STATE_LOG, COT_ROOT_DIR, COT_SYSLOG_LEVEL, COT_STDERR_LEVEL, COT_SYSLOG_NAME, COT_ASK_APPROVAL, COT_APPROVE, COT_TASK_LOG, COT_USIGN, COT_LAST
+	COT_BATCH, COT_NO_OP, COT_REEXEC, COT_REBOOT, COT_STATE_LOG, COT_ROOT_DIR, COT_SYSLOG_LEVEL, COT_STDERR_LEVEL, COT_SYSLOG_NAME, COT_ASK_APPROVAL, COT_APPROVE, COT_TASK_LOG, COT_USIGN, COT_NO_REPLAN, COT_LAST
 };
 
 static void print_help() {
@@ -122,6 +122,7 @@ int main(int argc, char *argv[]) {
 	size_t approval_count = 0;
 	const char *task_log = NULL;
 	const char *usign_exec = NULL;
+	bool no_replan = false;
 	for (; op->type != COT_EXIT && op->type != COT_CRASH; op ++)
 		switch (op->type) {
 			case COT_HELP:
@@ -184,6 +185,9 @@ int main(int argc, char *argv[]) {
 			case COT_USIGN:
 				usign_exec = op->parameter;
 				break;
+			case COT_NO_REPLAN:
+				no_replan = true;
+				break;
 			default:
 				DIE("Unknown COT");
 		}
@@ -206,6 +210,10 @@ int main(int argc, char *argv[]) {
 		const char *err = interpreter_call(interpreter, "uri.usign_exec_set", NULL, "s", usign_exec);
 		ASSERT_MSG(!err, "%s", err);
 	}
+	if (no_replan) {
+		const char *err = interpreter_call(interpreter, "updater.disable_replan", NULL, "");
+		ASSERT_MSG(!err, "%s", err);
+	}
 	bool trans_ok = true;
 	if (exit_type != COT_EXIT)
 		goto CLEANUP;
diff --git a/tests/planner.lua b/tests/planner.lua
index 73b48a4..f8d170c 100644
--- a/tests/planner.lua
+++ b/tests/planner.lua
@@ -1223,7 +1223,7 @@ function test_filter_required()
 			modifier = {}
 		}
 	}
-	local result = planner.filter_required(status, requests)
+	local result = planner.filter_required(status, requests, true)
 	local expected = {
 		requests[1],
 		{
@@ -1281,7 +1281,7 @@ function test_replan()
 			modifier = {}
 		}
 	}
-	local result = planner.filter_required({}, requests)
+	local result = planner.filter_required({}, requests, true)
 	assert_table_equal({
 		requests[1]
 	}, result)
@@ -1388,7 +1388,7 @@ function test_abi_change()
 			modifier = {}
 		}
 	}
-	local result = planner.filter_required(status, requests)
+	local result = planner.filter_required(status, requests, true)
 	local expected = {
 		requests[1],
 		requests[2],
@@ -1399,7 +1399,7 @@ function test_abi_change()
 	-- Update abi_change to abi_change_deep and repeat
 	requests[1].modifier.abi_change_deep = requests[1].modifier.abi_change
 	table.insert(expected, requests[5])
-	result = planner.filter_required(status, requests)
+	result = planner.filter_required(status, requests, true)
 	assert_table_equal(expected, result)
 end
 
-- 
2.13.0

